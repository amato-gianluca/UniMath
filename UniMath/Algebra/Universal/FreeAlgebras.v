(** * Variables and free algebras. *)

(**
   This file contains a formalization of terms with variables and the free algebra generated by
   an infinite set of variables, together with the corresponding universal mapping property.
 *)

Require Import UniMath.Foundations.All.

Require Export UniMath.Algebra.Universal.Algebras.
Require Export UniMath.Algebra.Universal.Terms.

Local Open Scope sorted.
Local Open Scope hom.

Section Variables.

  Definition varspec (σ: signature) := ∑ V: hSet, V → sorts σ.

  Definition make_varspec (σ: signature) (varsupp: hSet) (varsorts: varsupp → sorts σ)
    : varspec σ := (varsupp,, varsorts).

  Coercion varsupp {σ: signature}: varspec σ → hSet := pr1.

  Definition varsort {σ: signature} {V: varspec σ}: V → sorts σ := pr2 V.

  Definition vsignature (σ : signature) (V: varspec σ): signature
    := make_signature (sorts σ) (setcoprod (names σ) V) (sumofmaps (ar σ) (λ v, nil ,, varsort v)).

  Definition vterm (σ: signature) (V: varspec σ): sUU (sorts σ) := term (vsignature σ V).

  Definition vtermset (σ: signature) (V: varspec σ): shSet (sorts σ) := termset (vsignature σ V).

  Context {σ : signature}.

  Definition namelift {V: varspec σ} (nm: names σ): names (vsignature σ V) := inl nm.

  Definition varname {V: varspec σ} (v: V): names (vsignature σ V) := inr v.

  Definition varterm {V: varspec σ} (v: V): vterm σ V (varsort v) := build_term (varname v) [()].

  Definition assignment {σ: signature} (A: sUU (sorts σ)) (V: varspec σ) : UU := ∏ v: V, A (varsort v).

  Definition fromvterm {A: sUU (sorts σ)} {V: varspec σ}
                       (op : (∏ nm : names σ, A ⋆ (arity nm) → A (sort nm)))
                       (α : assignment A V)
    : vterm σ V s→ A.
  Proof.
    refine (@fromterm (vsignature σ V) A _).
    induction nm as [nm | v].
    - exact (op nm).
    - exact (λ _, α v).
  Defined.

  Lemma fromvtermstep {A: sUU (sorts σ)} {V: varspec σ}
                      (op : (∏ nm : names σ, A ⋆ (arity nm) → A (sort nm)))
                      (α : assignment A V)
                      (nm: names σ) (v:  vterm σ V ⋆ (arity nm))
    : fromvterm op α (sort nm) (build_term (namelift nm) v) = op nm (fromvterm op α ⋆⋆ (arity nm) v).
  Proof.
    unfold fromvterm, fromterm.
    rewrite (term_ind_step _ _  (namelift nm)).
    simpl.
    rewrite h2lower_h1map_h1lift.
    apply idpath.
  Defined.

  (** This used to be provable with apply idpath in the single sorted case **)
  Lemma fromvtermstep' {A: sUU (sorts σ)} {V: varspec σ}
                       (op : (∏ nm : names σ, A ⋆ (arity nm) → A (sort nm)))
                       (α : assignment A V)
                       (v: V)
    : fromvterm op α (varsort v) (build_term (varname v) [()]) = α v.
  Proof.
    unfold fromvterm, fromterm.
    rewrite (term_ind_step _ _  (varname v)).
    apply idpath.
  Defined.

End Variables.

Section FreeAlgebras.

  Definition free_algebra (σ: signature) (V: varspec σ): algebra σ :=
    @make_algebra σ (vtermset σ V) (build_term ∘ namelift).

  Context {σ: signature} (a : algebra σ) {V: varspec σ} (α: assignment a V).

  Definition veval: free_algebra σ V s→ a := fromvterm (ops a) α.

  Lemma vevalstep (nm: names σ) (v:  term (vsignature σ V) ⋆ (arity nm))
    : veval (sort (namelift nm)) (build_term (namelift nm) v) = ops a nm (veval ⋆⋆ (arity nm) v).
  Proof.
    unfold veval.
    change (sort (namelift nm)) with (sort nm).
    apply fromvtermstep.
  Defined.

  Lemma ishomveval: ishom veval.
  Proof.
    red.
    intros.
    apply vevalstep.
  Defined.

  Definition vevalhom: free_algebra σ V ↦ a := make_hom ishomveval.

  Definition universalmap: ∑ h: free_algebra σ V ↦ a, ∏ v: V, h _ (varterm v) = α v.
  Proof.
    exists vevalhom.
    intro v.
    simpl.
    unfold veval, varterm.
    apply fromvtermstep'.
  Defined.

  Definition iscontr_universalmap
    : iscontr (∑ h: free_algebra σ V ↦ a, ∏ v: V, h (varsort v) (varterm v) = α v).
  Proof.
    exists universalmap.
    intro h.
    induction h as [h honvars].
    apply subtypePairEquality'.
    - induction h as [h hishom].
      apply subtypePairEquality'.
      2: apply isapropishom.
      apply funextsec.
      intro s.
      apply funextfun.
      unfold homot.
      revert s.
      apply (term_ind(σ := vsignature σ V)).
      unfold term_ind_HP.
      intros nm hv IHhv.
      induction nm as [nm | v].
      * change (inl nm) with (namelift(V:=V) nm).
        change (sort (namelift nm)) with (sort nm) at 2.
        change (build_term (namelift nm) hv) with (free_algebra σ V nm hv) at 1.
        rewrite hishom.
        rewrite vevalstep.
        apply maponpaths.
        revert hv IHhv.
        change (@arity (vsignature σ V) (inl nm)) with (arity nm).
        generalize (arity nm).
        refine (list_ind _ _ _).
        -- reflexivity.
        -- intros x xs IHxs hv IHhv.
           unfold starfun.
             simpl.
             simpl in IHhv.
             apply hcons_paths.
             + exact (pr1 IHhv).
             + exact (IHxs (pr2 hv) (pr2 IHhv)).
      * induction hv.
        change (inr v) with (varname v).
        change (sort (varname v)) with (varsort v).
        rewrite honvars.
        unfold veval.
        rewrite fromvtermstep'.
        apply idpath.
   - apply impred_isaprop.
     intros.
     apply (supportset a (varsort t)).
  Defined.

End FreeAlgebras.
