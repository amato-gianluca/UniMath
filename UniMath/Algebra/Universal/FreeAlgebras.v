(** * Variables and free algebras. *)

(**
   This file contains a formalization of terms with variables and the free algebra generated by
   an infinite set of variables, together with the corresponding universal mapping property.
 *)

Require Import UniMath.Foundations.All.
Require Import UniMath.Combinatorics.Lists.
Require Import UniMath.Combinatorics.Vectors.

Require Import UniMath.Algebra.Universal.DecSet.
Require Import UniMath.Algebra.Universal.Signatures.
Require Import UniMath.Algebra.Universal.SortedTypes.
Require Import UniMath.Algebra.Universal.HVectors.
Require Import UniMath.Algebra.Universal.MoreLists.
Require Import UniMath.Algebra.Universal.Terms.
Require Import UniMath.Algebra.Universal.Algebras.

Local Open Scope hom.

Local Open Scope sorted.

Section Variables.

  Definition varspec (σ: signature) := ∑ V: hSet, V → sorts σ.

  Coercion varsupp {σ: signature}: varspec σ → hSet := pr1.

  Definition varsort {σ: signature} {V: varspec σ}: V → sorts σ := pr2 V.

  Definition vsignature (σ : signature) (V: varspec σ): signature
    := make_signature (sorts σ) (setcoprod (names σ) V) (sumofmaps (ar σ) (λ v, []%list ,, varsort v)).

  Definition vterm (σ: signature) (V: varspec σ) := term (vsignature σ V).

  Context {σ : signature}.

  Definition namelift {V: varspec σ} (nm: names σ): names (vsignature σ V) := inl nm.

  Definition varname {V: varspec σ} (v: V): names (vsignature σ V) := inr v.

  Definition var {V: varspec σ} (v: V): vterm σ V (varsort v) := build_term (varname v) [].

  Definition fromvterm {A: sUU (sorts σ)} {V: varspec σ}
             (op : (∏ nm : names σ, A ↑ (arity nm) → A (sort nm)))
             (α : ∏ v: V, A (varsort v))
    : vterm σ V s→ A.
  Proof.
    refine (@fromterm (vsignature σ V) A _).
    induction nm as [nm | nm].
    - exact (op nm).
    - exact (λ rec, α nm).
  Defined.

  Lemma fromvtermstep {A: sUU (sorts σ)}  {V: varspec σ}
                      (op : (∏ nm : names σ, A ↑ (arity nm) → A (sort nm)))
                      (α : ∏ v: V, A (varsort v))
                      (nm: names σ) (v:  term (vsignature σ V) ↑ (arity nm))
    : fromvterm op α (sort nm) (build_term (namelift nm) v) = op nm (fromvterm op α ↑↑ (arity nm) v).
  Proof.
    unfold fromvterm, fromterm.
    rewrite (term_ind_step _ _  (namelift nm)).
    simpl.
    rewrite hvec_lower_hmap_lift.
    apply idpath.
  Defined.

  (** This used to be provable with apply idpath in the single sorted case **)
  Lemma fromvtermstep' {A: sUU (sorts σ)} {V: varspec σ}
                      (op : (∏ nm : names σ, A ↑ (arity nm) → A (sort nm)))
                      (α : ∏ v: V, A (varsort v))
                      (v: V)
    : fromvterm op α (varsort v) (build_term (varname v) []) = α v.
  Proof.
    unfold fromvterm, fromterm.
    rewrite (term_ind_step _ _  (varname v)).
    apply idpath.
  Defined.

End Variables.

Section FreeAlgebras.

  Definition free_algebra (σ: signature) (V: varspec σ): algebra σ :=
    @make_algebra σ (@termset (vsignature σ V)) (λ nm: names σ, build_term (namelift nm)).

  Context {σ: signature} (a : algebra σ) {V: varspec σ} (α : ∏ v: V, support a (varsort v)).

  Definition veval: free_algebra σ V s→ a
    := fromvterm (ops a) α.

  Lemma vevalstep (nm: names σ) (v:  term (vsignature σ V) ↑ (arity nm))
    : veval (sort nm) (build_term (namelift nm) v) = ops a nm (veval ↑↑ (arity nm) v).
  Proof.
    unfold veval.
    apply fromvtermstep.
  Defined.

  Lemma ishomveval: ishom veval.
  Proof.
    red.
    intros.
    apply vevalstep.
  Defined.

  Definition vevalhom: free_algebra σ V ↦ a
    := make_hom ishomveval.

  Definition universalmap: ∑ h: free_algebra σ V ↦ a, ∏ v: V, h (varsort v) (var v) = α v.
  Proof.
    exists vevalhom.
    intro v.
    simpl.
    unfold veval, var.
    apply fromvtermstep'.
  Defined.

  Definition iscontr_universalmap
    : iscontr (∑ h: free_algebra σ V ↦ a, ∏ v: V, h (varsort v) (var v) = α v).
  Proof.
    exists universalmap.
    intro h.
    induction h as [h hvar].
    apply subtypePairEquality'.
    - apply subtypePairEquality'.
      2: apply isapropishom.
      apply funextsec.
      intro s.
      apply funextfun.
      unfold homot.
      revert s.
      change (sorts σ) with (sorts (vsignature σ V)).
      apply term_ind.
      unfold term_ind_HP.
      intros nm hv IH.
      induction nm as [nm | v].
      * change (inl nm) with (namelift(V:=V) nm).
        change (build_term (namelift nm) hv) with (ops (free_algebra σ V) nm hv) at 1.
        change (sort (namelift nm)) with (sort nm).
        rewrite (hom2axiom h).
        rewrite vevalstep.
        apply maponpaths.
        change ((term (vsignature σ V)) ↑ (arity nm)) in hv.
        revert hv IH.
        assert ( X:  ∏ l: list (sorts σ),  ∏ v : ((term (vsignature σ V)) ↑) l,HVec
  (hmap_vector (λ (s : pr1decSet (sorts (vsignature σ V))) (t : term (vsignature σ V) s), pr1 h s t = veval s t) v)
→ ((pr1 h) ↑↑) l v = (veval ↑↑) l v).
        {  refine (list_ind _ _ _).
           - reflexivity.
           - intros x xs IH' v IH.
             unfold starfun.
             simpl.
             simpl in IH.
             apply hvcons_paths.
             + exact (pr1 IH).
             + exact (IH' (pr2 v) (pr2 IH)).
        }
        exact (X (arity nm)).
      * change (inr v) with (varname v).
        change ((sort (varname v))) with (varsort v).
        cbn in hv.
        induction hv.
        rewrite hvar.
        unfold veval.
        rewrite fromvtermstep'.
        apply idpath.
   - apply impred_isaprop.
     intros.
     apply (pr1 a (varsort t)).
  Defined.

End FreeAlgebras.
