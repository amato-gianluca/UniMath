(** * Variables and free algebras. *)

(**
   This file contains a formalization of terms with variables and the free algebra generated by
   an infinite set of variables, together with the corresponding universal mapping property.
 *)

Require Import UniMath.Foundations.All.
Require Import UniMath.Combinatorics.Lists.

Require Import UniMath.Algebra.Universal.Signatures.
Require Import UniMath.Algebra.Universal.HVectors.
Require Import UniMath.Algebra.Universal.Terms.
Require Import UniMath.Algebra.Universal.Algebras.

Local Open Scope hom.

Local Open Scope sorted.

Section Variables.

  Definition varspec (σ: signature) := ∑ V: hSet, V → sorts σ.

  Coercion varsupp {σ: signature}: varspec σ → hSet := pr1.

  Definition varsort {σ: signature} {V: varspec σ}: V → sorts σ := pr2 V.

  Definition vsignature (σ : signature) (V: varspec σ): signature
    := make_signature (sorts σ) (setcoprod (names σ) V) (sumofmaps (ar σ) (λ v, nil ,, varsort v)).

  Definition vterm (σ: signature) (V: varspec σ): sUU (sorts σ) := term (vsignature σ V).

  Definition vtermset (σ: signature) (V: varspec σ): shSet (sorts σ) := termset (vsignature σ V).

  Context {σ : signature}.

  Definition namelift {V: varspec σ} (nm: names σ): names (vsignature σ V) := inl nm.

  Definition varname {V: varspec σ} (v: V): names (vsignature σ V) := inr v.

  Definition varterm {V: varspec σ} (v: V): vterm σ V (varsort v) := build_term (varname v) [].

  Definition fromvterm {A: sUU (sorts σ)} {V: varspec σ}
                       (op : (∏ nm : names σ, A ↑ (arity nm) → A (sort nm)))
                       (α : ∏ v: V, A (varsort v))
    : vterm σ V s→ A.
  Proof.
    refine (@fromterm (vsignature σ V) A _).
    induction nm as [nm | v].
    - exact (op nm).
    - exact (λ _, α v).
  Defined.

  Lemma fromvtermstep {A: sUU (sorts σ)} {V: varspec σ}
                      (op : (∏ nm : names σ, A ↑ (arity nm) → A (sort nm)))
                      (α : ∏ v: V, A (varsort v))
                      (nm: names σ) (v:  vterm σ V ↑ (arity nm))
    : fromvterm op α (sort nm) (build_term (namelift nm) v) = op nm (fromvterm op α ↑↑ (arity nm) v).
  Proof.
    unfold fromvterm, fromterm.
    rewrite (term_ind_step _ _  (namelift nm)).
    simpl.
    rewrite hvec_lower_hmap_lift.
    apply idpath.
  Defined.

  (** This used to be provable with apply idpath in the single sorted case **)
  Lemma fromvtermstep' {A: sUU (sorts σ)} {V: varspec σ}
                       (op : (∏ nm : names σ, A ↑ (arity nm) → A (sort nm)))
                       (α : ∏ v: V, A (varsort v))
                       (v: V)
    : fromvterm op α (varsort v) (build_term (varname v) []) = α v.
  Proof.
    unfold fromvterm, fromterm.
    rewrite (term_ind_step _ _  (varname v)).
    apply idpath.
  Defined.

End Variables.

Section FreeAlgebras.

  Definition free_algebra (σ: signature) (V: varspec σ): algebra σ :=
    @make_algebra σ (vtermset σ V) (build_term ∘ namelift).

  Context {σ: signature} (a : algebra σ) {V: varspec σ} (α : ∏ v: V, support a (varsort v)).

  Definition veval: free_algebra σ V s→ a := fromvterm (ops a) α.

  Lemma vevalstep (nm: names σ) (v:  term (vsignature σ V) ↑ (arity nm))
    : veval (sort (namelift nm)) (build_term (namelift nm) v) = ops a nm (veval ↑↑ (arity nm) v).
  Proof.
    unfold veval.
    change (sort (namelift nm)) with (sort nm).
    apply fromvtermstep.
  Defined.

  Lemma ishomveval: ishom veval.
  Proof.
    red.
    intros.
    apply vevalstep.
  Defined.

  Definition vevalhom: free_algebra σ V ↦ a := make_hom ishomveval.

  Definition universalmap: ∑ h: free_algebra σ V ↦ a, ∏ v: V, h _ (varterm v) = α v.
  Proof.
    exists vevalhom.
    intro v.
    simpl.
    unfold veval, varterm.
    apply fromvtermstep'.
  Defined.

  Definition iscontr_universalmap
    : iscontr (∑ h: free_algebra σ V ↦ a, ∏ v: V, h (varsort v) (varterm v) = α v).
  Proof.
    exists universalmap.
    intro h.
    induction h as [h honvars].
    apply subtypePairEquality'.
    - induction h as [h hishom].
      apply subtypePairEquality'.
      2: apply isapropishom.
      apply funextsec.
      intro s.
      apply funextfun.
      unfold homot.
      revert s.
      apply (term_ind(σ := vsignature σ V)).
      unfold term_ind_HP.
      intros nm hv IHhv.
      induction nm as [nm | v].
      * change (inl nm) with (namelift(V:=V) nm).
        change (sort (namelift nm)) with (sort nm) at 2.
        change (build_term (namelift nm) hv) with (free_algebra σ V nm hv) at 1.
        rewrite hishom.
        rewrite vevalstep.
        apply maponpaths.
        revert hv IHhv.
        change (@arity (vsignature σ V) (inl nm)) with (arity nm).
        generalize (arity nm).
        refine (list_ind _ _ _).
        -- reflexivity.
        -- intros x xs IHxs hv IHhv.
           unfold starfun.
             simpl.
             simpl in IHhv.
             apply hvcons_paths.
             + exact (pr1 IHhv).
             + exact (IHxs (pr2 hv) (pr2 IHhv)).
      * induction hv.
        change (inr v) with (varname v).
        change (sort (varname v)) with (varsort v).
        rewrite honvars.
        unfold veval.
        rewrite fromvtermstep'.
        apply idpath.
   - apply impred_isaprop.
     intros.
     apply (supportset a (varsort t)).
  Defined.

End FreeAlgebras.
